#------------------------------------------------------------------------------#
#                          WFP Standardized Scripts
#            ENA Vulnerability Classification Methodology
#------------------------------------------------------------------------------#

# NOTES:
# This script is based on the vulnerability classification methodology recommended 
# for Essential Needs Assessments. This classification is based on the combination 
# of three indicators: the Economic Capacity to Meet Essential Needs (ECMEN), the 
# Livelihood Coping Index for Essential Needs (LCS-EN), and the Food Consumption 
# Score (FCS). However, the vulnerability classification methodology can be adapted 
# based on programme needs. See chapter 6 of the Essential Needs Assessment guidance 
# note for more details.

# The script assumes that ECMEN, LCS-EN, and FCS have already been computed based 
# on standard scripts available in github: 
# https://github.com/WFP-VAM/RAMResourcesScripts/tree/main/Indicators. 
# The following variables should have been defined before running this file:
#   ECMEN_exclAsst
#   ECMEN_exclAsst_SMEB		
#   Max_coping_behaviourEN
#   FCSCat28 
#   FCSCat21 

import pandas as pd
import numpy as np

# Create temporary variables
data['temp_ECMEN_categ'] = np.where(data['ECMEN_exclAsst'] == 1, 0, 
                            np.where(data['ECMEN_exclAsst'] == 0 & data['ECMEN_exclAsst_SMEB'] == 1, 1, 
                            np.where(data['ECMEN_exclAsst_SMEB'] == 0, 2, np.nan)))

data['temp_ECMEN_categ'] = data['temp_ECMEN_categ'].map({0: 'above MEB', 1: 'below MEB and above SMEB', 2: 'below SMEB'})

# Declare whether the 21 or 28 threshold is used for FCS
data['temp_FCS_categ'] = data['FCSCat21'] # replace with data['FCSCat28'] if the CO uses 28 threshold

# Classify households into vulnerability categories
conditions = [
    (data['temp_ECMEN_categ'] == 2) | (data['Max_coping_behaviourEN'] == 4) | (data['temp_FCS_categ'] == 1),
    (data['temp_ECMEN_categ'] == 2) & (data['Max_coping_behaviourEN'] == 4),
    (data['temp_ECMEN_categ'] == 2) & (data['temp_FCS_categ'] == 1),
    (data['Max_coping_behaviourEN'] == 4) & (data['temp_FCS_categ'] == 1),
    (data['temp_ECMEN_categ'] == 1) & (data['Max_coping_behaviourEN'] < 4) & (data['temp_FCS_categ'].between(2, 3)),
    (data['temp_ECMEN_categ'] == 0) & (data['Max_coping_behaviourEN'] == 3) & (data['temp_FCS_categ'].between(2, 3)),
    (data['temp_ECMEN_categ'] == 0) & (data['Max_coping_behaviourEN'] < 3) & (data['temp_FCS_categ'] == 2),
    (data['temp_ECMEN_categ'] == 0) & (data['Max_coping_behaviourEN'] < 3) & (data['temp_FCS_categ'] == 3)
]
choices = [3, 4, 4, 4, 2, 2, 2, 1]
data['ENA_vulnerability'] = np.select(conditions, choices, default=np.nan)

data['ENA_vulnerability'] = data['ENA_vulnerability'].map({1: 'Not vulnerable', 2: 'Moderately vulnerable', 3: 'Highly vulnerable', 4: 'Extremely vulnerable'})

# Calculate the population share in vulnerability tiers
print(data['ENA_vulnerability'].value_counts(normalize=True) * 100)

# Drop unnecessary variables
data.drop(columns=['temp_ECMEN_categ', 'temp_FCS_categ'], inplace=True)

# End of Scripts